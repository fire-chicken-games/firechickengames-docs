{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome # Get Combat for Game Creator on the Unity Asset Store. The module introduces combat-related features to the Game Creator ecosystem, like weapon targeting and an efficient game object spawner. It provides optional integrations for both the Shooter and Melee modules. It has also been designed to work with the Behavior module and the Accessibility Features for Game Creator module's Mobile UI controls. Unity 2019.4 LTS (or higher) is required beginning with release v0.8.0 (previous versions required 2019.3 or newer). Combat Demos: Fire Chicken Games YouTube Channel Combat (and other) Tutorials: RVR YouTube Channel Discord: Game Creator Server's #Combat Channel","title":"Welcome"},{"location":"#welcome","text":"Get Combat for Game Creator on the Unity Asset Store. The module introduces combat-related features to the Game Creator ecosystem, like weapon targeting and an efficient game object spawner. It provides optional integrations for both the Shooter and Melee modules. It has also been designed to work with the Behavior module and the Accessibility Features for Game Creator module's Mobile UI controls. Unity 2019.4 LTS (or higher) is required beginning with release v0.8.0 (previous versions required 2019.3 or newer). Combat Demos: Fire Chicken Games YouTube Channel Combat (and other) Tutorials: RVR YouTube Channel Discord: Game Creator Server's #Combat Channel","title":"Welcome"},{"location":"combat/","text":"The Combat module adds enhanced, game-ready, combat features: Targeting Proximity-based Targeting (with programmatic API, actions, and triggers). Point-and-Click Mouse Targeting. AI Targeting (requires the Behavior module). Mobile UI Button Compatibility for Accessibility Module (by Pivec Labs). Customizable Target Indicator. Targeting by Visibility. Spawn System (with optional weighted random selection). Weapon Stashes (weapon carrying/switching mechanic). Melee and Shooter Integration (requires Melee and/or Shooter modules). Homing Projectile. Support for Destructible Targets. Dependencies # Combat is an extension for Game Creator . It is required - Combat will not work without it. They can be purchased from the Unity Asset Store: Game Creator The Melee and Shooter modules are optional dependencies. Get them here: Melee Shooter What\u2019s Included # Full source code. An examples module that contains scenes that demonstrate the features listed above. Module Installation # After purchasing and downloading the Combat module, it must be enabled with the Game Creator Module Manager. Step 1: Open the Module Manager # Step 2: Enable the Combat Module # Step 3 (optional): Install the Combat Examples Module # Melee and Shooter Module Integrations # The Combat module provides a lightweight integration to allow seamless Shooter/Melee targeting and weapon switching if the Melee module is present. To enable the integration, simply enable the included Combat (Melee) and/or Combat (Shooter) integration modules. Note that also included are the Combat Examples (Melee) and Combat Examples (Shooter) modules that demonstrate Melee/Shooter targeting and weapon switching.","title":"Getting Started"},{"location":"combat/#dependencies","text":"Combat is an extension for Game Creator . It is required - Combat will not work without it. They can be purchased from the Unity Asset Store: Game Creator The Melee and Shooter modules are optional dependencies. Get them here: Melee Shooter","title":"Dependencies"},{"location":"combat/#whats-included","text":"Full source code. An examples module that contains scenes that demonstrate the features listed above.","title":"What\u2019s Included"},{"location":"combat/#module-installation","text":"After purchasing and downloading the Combat module, it must be enabled with the Game Creator Module Manager.","title":"Module Installation"},{"location":"combat/#step-1-open-the-module-manager","text":"","title":"Step 1: Open the Module Manager"},{"location":"combat/#step-2-enable-the-combat-module","text":"","title":"Step 2: Enable the Combat Module"},{"location":"combat/#step-3-optional-install-the-combat-examples-module","text":"","title":"Step 3 (optional): Install the Combat Examples Module"},{"location":"combat/#melee-and-shooter-module-integrations","text":"The Combat module provides a lightweight integration to allow seamless Shooter/Melee targeting and weapon switching if the Melee module is present. To enable the integration, simply enable the included Combat (Melee) and/or Combat (Shooter) integration modules. Note that also included are the Combat Examples (Melee) and Combat Examples (Shooter) modules that demonstrate Melee/Shooter targeting and weapon switching.","title":"Melee and Shooter Module Integrations"},{"location":"combat/homing_projectiles/","text":"As the name suggests, a Homing Projectile seeks its target even if the weapon firing the projectile is not pointed directly at the intended target. Setup is trivial. Simply attach the Combat module\u2019s Homing Projectile component to any potential projectile. Target Mode : This setting determines how the target of the projectile is set. Targeter : The projectile's target comes from the Targeter component attached to the game object specified here. Target : The projectile's target comes directly from the this setting (and does not require a Combat module Targeter component). Ammo Rigidbody : This property will be automatically set if the game object contains a Rigidbody component. The Propulsion settings control the movement behavior of the projectile... Target Offset : This property offsets the location of the projectile's target... useful in cases where the target's transform root is not visually where the projectile should travel to. Propulsion Delay (seconds) : Delays the propulsion of the projectile by a number of seconds. A value of 0 (or less) results in no delay. Propel For (seconds) : Stop propelling the projectile after a number of seconds - should be greater than Propulsion Delay. Maximum Turn Angle : The maximum angle, in degrees, that the projectile will turn while homing in on its target. Velocity : How fast the projectile moves toward its target - this should likely match or exceed the max velocity of the projectile ammo if propulsion is delayed. If there is no delay, this setting will effectively override the projectile ammo\u2019s min/max velocity. Rigidybody Gravity Turning off gravity on the Rigidbody is optional, but might be desired depending on the specific projectile.","title":"Homing Projectile"},{"location":"combat/roadmap/","text":"Next Major Release # Targeting Features Shoot from Cover (requires Traversal and Shooter module) - on hold until GC Shooter and Traversal modules are updated to add support. Future Release # Targeting Features Body-part Targeting. Point and Click Ray-Based Shooting. Target-centric Movement (while targeting), i.e. circle and move toward the target while focused on it. Spawner Features Lootable/Drop Chance System. Random Item Drop (alternative to weighted random selection). Previous Releases # v0.12.0 # Homing Projectile Features New \"Targeting Mode\" to more flexibly configure the projectile's target. New Magnetic Mine and Missile Launch examples. v0.11.0 # Targeting Feature New \"On Continuing to be Targeted\" event/trigger. Bug Fixes Fix change camera motor action issue when using Targeter component. v0.10.0 # Targeting Feature New targeting type option for the Targeter component. New \"Aim Assist\" targeting type, i.e. focus on a target when the player's targeting reticule is near or on the target. New Custom Camera Motors for Targeter: Combat Targeting Camera Combat Aiming Camera Spawning Features Periodic Spawning. Support triggering spawn with non-GC character. v0.9.1 # Bug Fixes The Weapon Stash component produced a null reference error in its HasWeaponDrawn method when the Shooter was not enabled. The Combat Examples (Melee) demo scene had player with a Shooter component. v0.9.0 # Targeting Feature Targeter Camera Motors, optionally follow the current target with the camera while targeting or aiming with a Shooter weapon. Bug Fixes Combat Examples (Shooter) prefab weapon references have been restored. v0.8.1 # Bug Fixes Resolve various null reference issues with Shooter and Melee module integration. Remove Behavior module scripts (used for asset testing) from some prefabs. v0.8.0 # General Shooter module is now an optional dependency. Support is now enabled through the Combat (Shooter) module. Targeting Features Additional targeting actions to support the Behavior module. Improve Mouse Targeting Click current target to deselect it. Click no target to deselect the current target. Mouse targeting now enabled through the Targeter component. Weapon Stash Feature New action to remove weapon from stash. v0.7.0 # Targeting Features New public API for Targeter component: HasTarget GetCurrentTarget IsCurrentTarget SetCurrentTarget SetTargetingEnabled ToggleTargetingEnabled CycleToNextTarget New actions to enable, disable, and toggle targeting. New action to switch to next target. New \"On Target Changed\" trigger. Accessibility Module (by Pivec Labs) mobile touchstick compatibility. Mouse targeting w/ optional hover indicator (i.e. Targetable can be selected with mouse). Targeter's built-in user input controls can now be disabled. Targeter can now be configured to not auto-acquire first/next target. Spawning Features Spawn by Weight (i.e. random spawn chance). Bug Fixes Targetable's internal event now correctly cleaned up. When created from GameObject menu, a Spawner's collider now is set as a trigger by default. v0.6.0 # Spawner component. v0.5.0 # Melee targeting integration. Weapon Stashes (weapon carrying/switching feature). v0.4.1 # Removed .blend files that caused an issue when Blender was not installed. v0.4.0 # Targeting by visibility. Support for destructible targets. v0.3.0 # Proximity-based weapon targeting. Target indicator. Homing projectile.","title":"Roadmap"},{"location":"combat/roadmap/#next-major-release","text":"Targeting Features Shoot from Cover (requires Traversal and Shooter module) - on hold until GC Shooter and Traversal modules are updated to add support.","title":"Next Major Release"},{"location":"combat/roadmap/#future-release","text":"Targeting Features Body-part Targeting. Point and Click Ray-Based Shooting. Target-centric Movement (while targeting), i.e. circle and move toward the target while focused on it. Spawner Features Lootable/Drop Chance System. Random Item Drop (alternative to weighted random selection).","title":"Future Release"},{"location":"combat/roadmap/#previous-releases","text":"","title":"Previous Releases"},{"location":"combat/roadmap/#v0120","text":"Homing Projectile Features New \"Targeting Mode\" to more flexibly configure the projectile's target. New Magnetic Mine and Missile Launch examples.","title":"v0.12.0"},{"location":"combat/roadmap/#v0110","text":"Targeting Feature New \"On Continuing to be Targeted\" event/trigger. Bug Fixes Fix change camera motor action issue when using Targeter component.","title":"v0.11.0"},{"location":"combat/roadmap/#v0100","text":"Targeting Feature New targeting type option for the Targeter component. New \"Aim Assist\" targeting type, i.e. focus on a target when the player's targeting reticule is near or on the target. New Custom Camera Motors for Targeter: Combat Targeting Camera Combat Aiming Camera Spawning Features Periodic Spawning. Support triggering spawn with non-GC character.","title":"v0.10.0"},{"location":"combat/roadmap/#v091","text":"Bug Fixes The Weapon Stash component produced a null reference error in its HasWeaponDrawn method when the Shooter was not enabled. The Combat Examples (Melee) demo scene had player with a Shooter component.","title":"v0.9.1"},{"location":"combat/roadmap/#v090","text":"Targeting Feature Targeter Camera Motors, optionally follow the current target with the camera while targeting or aiming with a Shooter weapon. Bug Fixes Combat Examples (Shooter) prefab weapon references have been restored.","title":"v0.9.0"},{"location":"combat/roadmap/#v081","text":"Bug Fixes Resolve various null reference issues with Shooter and Melee module integration. Remove Behavior module scripts (used for asset testing) from some prefabs.","title":"v0.8.1"},{"location":"combat/roadmap/#v080","text":"General Shooter module is now an optional dependency. Support is now enabled through the Combat (Shooter) module. Targeting Features Additional targeting actions to support the Behavior module. Improve Mouse Targeting Click current target to deselect it. Click no target to deselect the current target. Mouse targeting now enabled through the Targeter component. Weapon Stash Feature New action to remove weapon from stash.","title":"v0.8.0"},{"location":"combat/roadmap/#v070","text":"Targeting Features New public API for Targeter component: HasTarget GetCurrentTarget IsCurrentTarget SetCurrentTarget SetTargetingEnabled ToggleTargetingEnabled CycleToNextTarget New actions to enable, disable, and toggle targeting. New action to switch to next target. New \"On Target Changed\" trigger. Accessibility Module (by Pivec Labs) mobile touchstick compatibility. Mouse targeting w/ optional hover indicator (i.e. Targetable can be selected with mouse). Targeter's built-in user input controls can now be disabled. Targeter can now be configured to not auto-acquire first/next target. Spawning Features Spawn by Weight (i.e. random spawn chance). Bug Fixes Targetable's internal event now correctly cleaned up. When created from GameObject menu, a Spawner's collider now is set as a trigger by default.","title":"v0.7.0"},{"location":"combat/roadmap/#v060","text":"Spawner component.","title":"v0.6.0"},{"location":"combat/roadmap/#v050","text":"Melee targeting integration. Weapon Stashes (weapon carrying/switching feature).","title":"v0.5.0"},{"location":"combat/roadmap/#v041","text":"Removed .blend files that caused an issue when Blender was not installed.","title":"v0.4.1"},{"location":"combat/roadmap/#v040","text":"Targeting by visibility. Support for destructible targets.","title":"v0.4.0"},{"location":"combat/roadmap/#v030","text":"Proximity-based weapon targeting. Target indicator. Homing projectile.","title":"v0.3.0"},{"location":"combat/spawner/","text":"A Spawner manages the creation of game objects (often enemies, loot, and visual effects like flames). The Combat module's Spawner component uses object pooling to efficiently manage multiple pools of spawnable objects. Spawner Component # A Spawner component can be added to any game object. It has built in support for spawning, despawning, and respawning based on the player's interaction with and proximity from an attached collider. Manual control of the component via Game Creator actions is also supported. Spawning # Snap to Ground # When enabled, the Y position of the spawned object is dynamically set to the ground under the object - effectively \"snapping\" the object to the terrain below. This prevents objects from being spawned under or above uneven terrain, then hovering out of site or falling (if the spawned object has a rigid body component). Pattern Type # Spawning can be done in a variety of patterns, relative to the position of the Spawner : Default Randomly places spawned objects in a developer designated radius around the Spawner . If the number of objects is sufficiently large and the spawn radius is too small/minimum spacing is too large, then objects that do not fit in the spawn area will not be spawned. Spiral Places spawned objects in a classic spiral pattern, with the center of the spiral originating at the Spawner . This pattern is useful for small clusters of objects, like a small group of ~5 enemies. Random with Overlap Randomly places spawned objects within a developer defined 3 dimensional area around the Spawner . The objects may (or may not) overlap, depending on object density in the spawn area size. This pattern is useful for spawning visual effects (e.g. flames, dust, etc.). At Spawner Origin Places all objects exactly at the Spawner's origin. This pattern is useful for spawning a single complicated prefab (rather than spawning parts of the prefab as individual spawnable items). Periodically Spawn # If enabled, the spawnables will appear periodically based on a timer. Spawn Rate (Seconds) # The number of seconds before a spawnable will appear. Skip Chance # The chance that nothing will appear during a spawn. Spawn Rate After Skip (Seconds) # The number of seconds to wait after a spawn is skipped. This setting, in combination with Skip Chance can add variability to spawning to make it feel more organic. Spawn by Weight # If enabled, a spawnable is randomly spawned using a simple weight-based selection formula. For example, if spawnable 1 has a weight of 25 and spawnable 2 has a weight of 100 , spawnable 1 will be spawned 20% of the time and spawnable 2 will be spawned 80% of the time. 1 2 Spawnable 1: 25 / (25 + 100) = 20% Spawnable 2: 100 / (25 + 100) = 80% Spawnables # The list of spawnables defines which (and how many) objects are spawned by the Spawner component. If the Spawn by Weight feature is disabled, the spawnables' Weight property is disregarded. Respawning # Spawnable objects can be automatically respawned either immediately after the player re-enters the spawn zone or after a developer defined delay. Enabled # If enabled, spawned objects will be automatically respawned when the player re-enters the spawn zone. Cooldown # If enabled, a respawn will only happen after a specified number of seconds. Despawning # Despawn by Distance # If enabled, spawned objects will be automatically despawned when the player leaves the spawn zone and is a set distance from the closest spawned object. Auto-calculate Distance # If enabled, the despawning distance will be automatically computed. The auto-calculated spawn distance is the radius of an attached SphereCollider or the average height/width of an attached BoxCollider . Despawn Distance # The distance the player has to travel from the Spawner's origin before the objects are automatically despawned. This property is disregarded if Auto-calculate Distance is enabled. Game Creator Actions # A Spawner can be manually controlled with the Spawn and Despawn actions, included with the Combat module. Any standard Game Creator trigger can be used to invoke these actions. Spawn Action # Select an object that has a Spawner component as the actions target. Disable the Despawn by Distance option when manually controlling the Spawner with triggers/actions, or the objects will never appear to spawn. Despawn Action # Select an object that has a Spawner component as the actions target.","title":"Spawner"},{"location":"combat/spawner/#spawner-component","text":"A Spawner component can be added to any game object. It has built in support for spawning, despawning, and respawning based on the player's interaction with and proximity from an attached collider. Manual control of the component via Game Creator actions is also supported.","title":"Spawner Component"},{"location":"combat/spawner/#spawning","text":"","title":"Spawning"},{"location":"combat/spawner/#snap-to-ground","text":"When enabled, the Y position of the spawned object is dynamically set to the ground under the object - effectively \"snapping\" the object to the terrain below. This prevents objects from being spawned under or above uneven terrain, then hovering out of site or falling (if the spawned object has a rigid body component).","title":"Snap to Ground"},{"location":"combat/spawner/#pattern-type","text":"Spawning can be done in a variety of patterns, relative to the position of the Spawner : Default Randomly places spawned objects in a developer designated radius around the Spawner . If the number of objects is sufficiently large and the spawn radius is too small/minimum spacing is too large, then objects that do not fit in the spawn area will not be spawned. Spiral Places spawned objects in a classic spiral pattern, with the center of the spiral originating at the Spawner . This pattern is useful for small clusters of objects, like a small group of ~5 enemies. Random with Overlap Randomly places spawned objects within a developer defined 3 dimensional area around the Spawner . The objects may (or may not) overlap, depending on object density in the spawn area size. This pattern is useful for spawning visual effects (e.g. flames, dust, etc.). At Spawner Origin Places all objects exactly at the Spawner's origin. This pattern is useful for spawning a single complicated prefab (rather than spawning parts of the prefab as individual spawnable items).","title":"Pattern Type"},{"location":"combat/spawner/#periodically-spawn","text":"If enabled, the spawnables will appear periodically based on a timer.","title":"Periodically Spawn"},{"location":"combat/spawner/#spawn-rate-seconds","text":"The number of seconds before a spawnable will appear.","title":"Spawn Rate (Seconds)"},{"location":"combat/spawner/#skip-chance","text":"The chance that nothing will appear during a spawn.","title":"Skip Chance"},{"location":"combat/spawner/#spawn-rate-after-skip-seconds","text":"The number of seconds to wait after a spawn is skipped. This setting, in combination with Skip Chance can add variability to spawning to make it feel more organic.","title":"Spawn Rate After Skip (Seconds)"},{"location":"combat/spawner/#spawn-by-weight","text":"If enabled, a spawnable is randomly spawned using a simple weight-based selection formula. For example, if spawnable 1 has a weight of 25 and spawnable 2 has a weight of 100 , spawnable 1 will be spawned 20% of the time and spawnable 2 will be spawned 80% of the time. 1 2 Spawnable 1: 25 / (25 + 100) = 20% Spawnable 2: 100 / (25 + 100) = 80%","title":"Spawn by Weight"},{"location":"combat/spawner/#spawnables","text":"The list of spawnables defines which (and how many) objects are spawned by the Spawner component. If the Spawn by Weight feature is disabled, the spawnables' Weight property is disregarded.","title":"Spawnables"},{"location":"combat/spawner/#respawning","text":"Spawnable objects can be automatically respawned either immediately after the player re-enters the spawn zone or after a developer defined delay.","title":"Respawning"},{"location":"combat/spawner/#enabled","text":"If enabled, spawned objects will be automatically respawned when the player re-enters the spawn zone.","title":"Enabled"},{"location":"combat/spawner/#cooldown","text":"If enabled, a respawn will only happen after a specified number of seconds.","title":"Cooldown"},{"location":"combat/spawner/#despawning","text":"","title":"Despawning"},{"location":"combat/spawner/#despawn-by-distance","text":"If enabled, spawned objects will be automatically despawned when the player leaves the spawn zone and is a set distance from the closest spawned object.","title":"Despawn by Distance"},{"location":"combat/spawner/#auto-calculate-distance","text":"If enabled, the despawning distance will be automatically computed. The auto-calculated spawn distance is the radius of an attached SphereCollider or the average height/width of an attached BoxCollider .","title":"Auto-calculate Distance"},{"location":"combat/spawner/#despawn-distance","text":"The distance the player has to travel from the Spawner's origin before the objects are automatically despawned. This property is disregarded if Auto-calculate Distance is enabled.","title":"Despawn Distance"},{"location":"combat/spawner/#game-creator-actions","text":"A Spawner can be manually controlled with the Spawn and Despawn actions, included with the Combat module. Any standard Game Creator trigger can be used to invoke these actions.","title":"Game Creator Actions"},{"location":"combat/spawner/#spawn-action","text":"Select an object that has a Spawner component as the actions target. Disable the Despawn by Distance option when manually controlling the Spawner with triggers/actions, or the objects will never appear to spawn.","title":"Spawn Action"},{"location":"combat/spawner/#despawn-action","text":"Select an object that has a Spawner component as the actions target.","title":"Despawn Action"},{"location":"combat/weapon_stashes/","text":"Weapon Stashes is a lightweight inventory system to assign weapons to a Player Character and allow the player to switch between them. It is compatible with both Shooter and Melee module weapons. Currently, only a weapon's default ammo is supported. Weapon Stash Component # A Weapon Stash must be added to a game object (usually the player): Adding a Weapon # There are two actions for adding weapons: Give Shooter Weapon and Give Melee Weapon. When configuring these actions, be sure to select the Target Game Object (usually the player) with a Weapon Stash . Changing Weapons # The current weapon can be switched to the next (or previous) weapon in the stash with the Cycle to Next Weapon action. Weapon Stash UI Component # The Weapon Stash UI component allows a stash's current weapon and ammo (if any) to be displayed on screen. This component differs the Shooter module's AmmoUI component in that it contains weapon information, not just ammo. Also, it will display the name of Melee module weapons (not just Shooter weapons). The Combat Examples module includes a WeaponStashUI prefab that demonstrates how to use the component:","title":"Weapon Stashes"},{"location":"combat/weapon_stashes/#weapon-stash-component","text":"A Weapon Stash must be added to a game object (usually the player):","title":"Weapon Stash Component"},{"location":"combat/weapon_stashes/#adding-a-weapon","text":"There are two actions for adding weapons: Give Shooter Weapon and Give Melee Weapon. When configuring these actions, be sure to select the Target Game Object (usually the player) with a Weapon Stash .","title":"Adding a Weapon"},{"location":"combat/weapon_stashes/#changing-weapons","text":"The current weapon can be switched to the next (or previous) weapon in the stash with the Cycle to Next Weapon action.","title":"Changing Weapons"},{"location":"combat/weapon_stashes/#weapon-stash-ui-component","text":"The Weapon Stash UI component allows a stash's current weapon and ammo (if any) to be displayed on screen. This component differs the Shooter module's AmmoUI component in that it contains weapon information, not just ammo. Also, it will display the name of Melee module weapons (not just Shooter weapons). The Combat Examples module includes a WeaponStashUI prefab that demonstrates how to use the component:","title":"Weapon Stash UI Component"},{"location":"combat/targeting/overview/","text":"The Combat module provides a proximity-based targeting system. It allows a player to target characters (or other game objects) within a configurable range. This is achieved with two components: Targeter and Targetable . When a player with a Targeter component approaches objects with the Targetable component attached, the player can press the Q key to lock onto the nearest available object. The Z and C keys are used to switch targets. Please note that these keys can be remapped .","title":"Overview"},{"location":"combat/targeting/targetable/","text":"Making game objects targetable using the Combat module\u2019s Targetable component is trivial for Game Creator Characters and other game objects. Basic Setup # Characters # To make a character targetable, simply add the Targetable component to it. Non-Character Game Objects # Any game object can be targetable if it has the Targetable , Rigidbody , and Collider components. Making a Target Untargetable # The Targetable component contains a boolean Game Creator Variable property, called Can Be Targeted , that can make the target untargetable. For example, once the target has been defeated, it is likely desirable for the player to automatically stop targeting it and not be able to target it again. This is accomplished by: Adding a boolean Local Variable to a character (e.g. \"IsAlive\"). Assigning the boolean variable to the Can Be Targeted property. In the character\u2019s On Receive Shot Actions , set the boolean value to false - this will deselect the target and make it no longer targetable. The Combat Examples module\u2019s Example4-KillableCharacters demo scene contains a pre-configured KillableCharacter prefab. It demonstrates how to make a character killable/untargetable using the method described above. Visibility Detection Renderer This property is used to determine if a Targetable's mesh is visible to a Targeter component. It does not normally need to be manually set (if not set, the component uses the first renderer found in the object's hierarchy). This property only needs to be manually set if the Targetable component's parent object does not have a mesh renderer in its hierarchy, or a mesh renderer other than the first one the GetComponentInChildren<Renderer>() returns by default is required. If visibility features are not used, this property can be ignored completely. \"On Target Become Untargetable\" Trigger # New in 0.4.0 There is also a trigger called \"On Target Become Untargetable\" that allows for actions to be executed when the target becomes untargetable. The Combat Examples module\u2019s Example7-DestructibleTargets demo scene contains a pre-configured DestructibleTarget prefab. It showcases how to use this trigger to implement destructible targets. Advanced Options # Active Target Indicator # The Targetable component provides an \"indicator\" feature that highlights the currently targeted game object. The content and appearance of the indicator is configurable. Text # An indicator can have custom text, defined via a Game Creator Global/Local Variable . Practically speaking, it almost always makes sense to use a Local Variable packaged in the same prefab object that contains the Targetable component. The value of the Local Variable would then be configured on the instance of the prefab when used in a scene. Prefab # If not set, the Game Creator Floating Message prefab is automatically set as the target indicator prefab at runtime. The Combat Examples module includes an example of a custom indicator. The example indicator has text above a downward pointing arrow. Positioning # The target indicator is positioned relative to the parent game object. By default, the Indicator Offset vector will position the indicator above the Game Creator example character, but may need to be adjusted for other characters and objects of with heights. Targeting Actions # A Targetable game object can optionally execute actions when it becomes the active target, and another set of actions when some other object becomes the active target (or targeting is toggled off altogether). \"On Become Active Target\" # When the target becomes the active target, these actions can (for example) make the target crouch. A more practical example might be adding an outline around the target or perhaps set a variable that triggers some behavior (e.g. make the target hostile or flee). \"On Not Active Target\" # Related to the previous section, when the target is changed or targeting is disabled, this action will reset the target character\u2019s gesture state. \"On Continuing To Be Targeted\" # Actions that are periodically executed while the target continues to be targeted. This is useful, for example, for repeating an attack on an enemy with a cooldown or otherwise having the target behave in some specific way.","title":"Targetable"},{"location":"combat/targeting/targetable/#basic-setup","text":"","title":"Basic Setup"},{"location":"combat/targeting/targetable/#characters","text":"To make a character targetable, simply add the Targetable component to it.","title":"Characters"},{"location":"combat/targeting/targetable/#non-character-game-objects","text":"Any game object can be targetable if it has the Targetable , Rigidbody , and Collider components.","title":"Non-Character Game Objects"},{"location":"combat/targeting/targetable/#making-a-target-untargetable","text":"The Targetable component contains a boolean Game Creator Variable property, called Can Be Targeted , that can make the target untargetable. For example, once the target has been defeated, it is likely desirable for the player to automatically stop targeting it and not be able to target it again. This is accomplished by: Adding a boolean Local Variable to a character (e.g. \"IsAlive\"). Assigning the boolean variable to the Can Be Targeted property. In the character\u2019s On Receive Shot Actions , set the boolean value to false - this will deselect the target and make it no longer targetable. The Combat Examples module\u2019s Example4-KillableCharacters demo scene contains a pre-configured KillableCharacter prefab. It demonstrates how to make a character killable/untargetable using the method described above. Visibility Detection Renderer This property is used to determine if a Targetable's mesh is visible to a Targeter component. It does not normally need to be manually set (if not set, the component uses the first renderer found in the object's hierarchy). This property only needs to be manually set if the Targetable component's parent object does not have a mesh renderer in its hierarchy, or a mesh renderer other than the first one the GetComponentInChildren<Renderer>() returns by default is required. If visibility features are not used, this property can be ignored completely.","title":"Making a Target Untargetable"},{"location":"combat/targeting/targetable/#on-target-become-untargetable-trigger","text":"New in 0.4.0 There is also a trigger called \"On Target Become Untargetable\" that allows for actions to be executed when the target becomes untargetable. The Combat Examples module\u2019s Example7-DestructibleTargets demo scene contains a pre-configured DestructibleTarget prefab. It showcases how to use this trigger to implement destructible targets.","title":"\"On Target Become Untargetable\" Trigger"},{"location":"combat/targeting/targetable/#advanced-options","text":"","title":"Advanced Options"},{"location":"combat/targeting/targetable/#active-target-indicator","text":"The Targetable component provides an \"indicator\" feature that highlights the currently targeted game object. The content and appearance of the indicator is configurable.","title":"Active Target Indicator"},{"location":"combat/targeting/targetable/#text","text":"An indicator can have custom text, defined via a Game Creator Global/Local Variable . Practically speaking, it almost always makes sense to use a Local Variable packaged in the same prefab object that contains the Targetable component. The value of the Local Variable would then be configured on the instance of the prefab when used in a scene.","title":"Text"},{"location":"combat/targeting/targetable/#prefab","text":"If not set, the Game Creator Floating Message prefab is automatically set as the target indicator prefab at runtime. The Combat Examples module includes an example of a custom indicator. The example indicator has text above a downward pointing arrow.","title":"Prefab"},{"location":"combat/targeting/targetable/#positioning","text":"The target indicator is positioned relative to the parent game object. By default, the Indicator Offset vector will position the indicator above the Game Creator example character, but may need to be adjusted for other characters and objects of with heights.","title":"Positioning"},{"location":"combat/targeting/targetable/#targeting-actions","text":"A Targetable game object can optionally execute actions when it becomes the active target, and another set of actions when some other object becomes the active target (or targeting is toggled off altogether).","title":"Targeting Actions"},{"location":"combat/targeting/targetable/#on-become-active-target","text":"When the target becomes the active target, these actions can (for example) make the target crouch. A more practical example might be adding an outline around the target or perhaps set a variable that triggers some behavior (e.g. make the target hostile or flee).","title":"\"On Become Active Target\""},{"location":"combat/targeting/targetable/#on-not-active-target","text":"Related to the previous section, when the target is changed or targeting is disabled, this action will reset the target character\u2019s gesture state.","title":"\"On Not Active Target\""},{"location":"combat/targeting/targetable/#on-continuing-to-be-targeted","text":"Actions that are periodically executed while the target continues to be targeted. This is useful, for example, for repeating an attack on an enemy with a cooldown or otherwise having the target behave in some specific way.","title":"\"On Continuing To Be Targeted\""},{"location":"combat/targeting/targeter/","text":"Included in the Combat Examples module is a prefab called PlayerTargeter that demonstrates how to use the Targeter component. The Sphere Collider attached to the same game object (as depicted in the inspector screenshot below) is required. Note that the range of the Targeter is dictated by the Radius property of this collider. The PlayerTargeter prefab should be nested under the Game Creator Player object. Aiming # Auto Aim At Target # Automatically aiming at a target can be disabled with the Auto Aim At Target option - the character will still be locked on to it, but will not fix their weapon on it while aiming. This may be desirable for some games. Camera Motor # If set, the camera will switch to this alternative camera motor while aiming at a target. Targeting # Enable # If enabled, targeting will be enabled when the scene loads. Acquire Initial Target # If enabled, the closest target will be automatically set if one is available. This is useful to disable for mouse targeting Continuing To Be Targeted Event Period (in seconds) # The number of seconds between triggering the Targetable's \"Continuing To Focus\" event. Camera Motor # If set, the camera will switch to this alternative camera motor while targeting A target. Type # This setting specifies the type of targeting strategy that is used to select and interact with targets. Each mode has a separate set of sub properties to configure the type-specific targeting. Proximity # Proximity targeting has a variety of target visibility options and user input control options. They allow for target selection to be limited by what the camera can see and/or what the player model can \"see\" from its perspective. Only Target Visible To Camera # If enabled, only targets possibly visible to the camera (i.e. in its view frustum) are targetable. Only Target Non-Occluded # If enabled, targets hidden behind objects are not targetable. Note that this option is turned off by default because the player and targetables need to be on dedicated layers which requires manual configuration. Layers To Ignore For Visibility Occlusion # The layers to ignore when determining target visibility when Only Target Non-Occluded is enabled. Typically, there should be two layers: A \"Targetable\" layer that contains all targetable objects. A \"Player\" layer that contains the player. User Input # The User Input section of the Targeter component allows the keys that control target locking and switching to be customized. Mouse # Mouse targeting has no type-specific settings. Aim Assist # Aim assist targeting requires the Shooter module. When a player aims at a target with a Shooter weapon, the Targeter locks onto the target. Moving the mouse/joystick/trackpad disengages the target lock. Mouse Aim Assist - Requires the shooter module. Deselect Target Input Threshold # The amount of horizontal movement it takes to deselect an aim assist target. This property makes the lock more \"sticky.\" Acquire Target Delay (Seconds) # The number of seconds to wait before a new target can be acquired. A small delay is useful if targets are dense, but normally this setting should not be adjusted.","title":"Targeter"},{"location":"combat/targeting/targeter/#aiming","text":"","title":"Aiming"},{"location":"combat/targeting/targeter/#auto-aim-at-target","text":"Automatically aiming at a target can be disabled with the Auto Aim At Target option - the character will still be locked on to it, but will not fix their weapon on it while aiming. This may be desirable for some games.","title":"Auto Aim At Target"},{"location":"combat/targeting/targeter/#camera-motor","text":"If set, the camera will switch to this alternative camera motor while aiming at a target.","title":"Camera Motor"},{"location":"combat/targeting/targeter/#targeting","text":"","title":"Targeting"},{"location":"combat/targeting/targeter/#enable","text":"If enabled, targeting will be enabled when the scene loads.","title":"Enable"},{"location":"combat/targeting/targeter/#acquire-initial-target","text":"If enabled, the closest target will be automatically set if one is available. This is useful to disable for mouse targeting","title":"Acquire Initial Target"},{"location":"combat/targeting/targeter/#continuing-to-be-targeted-event-period-in-seconds","text":"The number of seconds between triggering the Targetable's \"Continuing To Focus\" event.","title":"Continuing To Be Targeted Event Period (in seconds)"},{"location":"combat/targeting/targeter/#camera-motor_1","text":"If set, the camera will switch to this alternative camera motor while targeting A target.","title":"Camera Motor"},{"location":"combat/targeting/targeter/#type","text":"This setting specifies the type of targeting strategy that is used to select and interact with targets. Each mode has a separate set of sub properties to configure the type-specific targeting.","title":"Type"},{"location":"combat/targeting/targeter/#proximity","text":"Proximity targeting has a variety of target visibility options and user input control options. They allow for target selection to be limited by what the camera can see and/or what the player model can \"see\" from its perspective.","title":"Proximity"},{"location":"combat/targeting/targeter/#only-target-visible-to-camera","text":"If enabled, only targets possibly visible to the camera (i.e. in its view frustum) are targetable.","title":"Only Target Visible To Camera"},{"location":"combat/targeting/targeter/#only-target-non-occluded","text":"If enabled, targets hidden behind objects are not targetable. Note that this option is turned off by default because the player and targetables need to be on dedicated layers which requires manual configuration.","title":"Only Target Non-Occluded"},{"location":"combat/targeting/targeter/#layers-to-ignore-for-visibility-occlusion","text":"The layers to ignore when determining target visibility when Only Target Non-Occluded is enabled. Typically, there should be two layers: A \"Targetable\" layer that contains all targetable objects. A \"Player\" layer that contains the player.","title":"Layers To Ignore For Visibility Occlusion"},{"location":"combat/targeting/targeter/#user-input","text":"The User Input section of the Targeter component allows the keys that control target locking and switching to be customized.","title":"User Input"},{"location":"combat/targeting/targeter/#mouse","text":"Mouse targeting has no type-specific settings.","title":"Mouse"},{"location":"combat/targeting/targeter/#aim-assist","text":"Aim assist targeting requires the Shooter module. When a player aims at a target with a Shooter weapon, the Targeter locks onto the target. Moving the mouse/joystick/trackpad disengages the target lock. Mouse Aim Assist - Requires the shooter module.","title":"Aim Assist"},{"location":"combat/targeting/targeter/#deselect-target-input-threshold","text":"The amount of horizontal movement it takes to deselect an aim assist target. This property makes the lock more \"sticky.\"","title":"Deselect Target Input Threshold"},{"location":"combat/targeting/targeter/#acquire-target-delay-seconds","text":"The number of seconds to wait before a new target can be acquired. A small delay is useful if targets are dense, but normally this setting should not be adjusted.","title":"Acquire Target Delay (Seconds)"},{"location":"devkit/","text":"Release: 0.1.0 DevKit provides a variety of animation and transform-manipulation components, as well as a GameObject abstraction component to add flexibility to the asset's various components. The components are built on top of an extensible programmatic API. A simple Character component is also included and used in the asset's example scenes. Several models, prefabs, materials, textures, and shaders are also included for demo purposes as well. Animation Components # Component Description Animate Base The core animation component which other animation components extend. Animate Animates a GameObject with one or more Animation Settings . Animation Settings Contains properties that define a set of animations used to configure other components. Follow This component moves a GameObject along the x , y , and/or z dimensions of another GameObject . Move Point To Point Moves a GameObject from one location to another location. On Collision \u2192 Animate Animates a GameObject when collided with. On Collision \u2192 Move To Moves a GameObject to the location of another GameObject . Recolor Randomly Randomly changes the color of a Material . Rotate Perpetually Continually rotates a GameObject . AnimationBase # This is an abstract component that other animation components inherit. It cannot be added directly to a GameObject . 1 2 3 using FireChickenGames.DevKit.Components ; public class AnimationExample : AnimationBase { } The component provides an extensible base implementation that other animation components use to accomplish specific animation effects. Animate # The component can provide a simple one-off animation. Or a series of animations. Animation Settings # The component is used to visually configure an animation. Certain other components, such as the Animate component, use this component to define which animations they run. Follow # This component moves a GameObject along the x , y , and/or z dimensions of another GameObject . Animation Type Option Description Smooth Smooths the follow motion using Unity's Vector3.SmoothDamp function - useful for a follow camera. Ease Use a DevKit tween animation to animate the follow motion. One To One Lock the position of the following GameObject , with no smoothing or animation, to the GameObject it is following. Move Point To Point # The component moves the animated GameObject from one location to another location. On Collision \u2192 Animate # The component is used to apply animation configuration from an AnimationSettings component to the animated GameObject . The AnimationSettings can either come from the colliding GameObject (if it has an AnimationSettings component)... ...or be explicitly set in the inspector. On Collision \u2192 Move To # The component moves the component's GameObject toward the GameObject it collided with. Colliding objects are filterable by their tag. Recolor Randomly # The component changes the color of a material to another random color. This component is mainly for to demonstrate how to animate a color change. Rotate Perpetually # The component simply rotates a GameObject indefinitely. Animation API # The DevKit animation API allows for convenient animation of Transform , RectTransform , and Renderer components via C# extension methods. To get started, be sure to import the Tweening namespace: 1 using FireChickenGames.DevKit.Tweening ; Animating Transforms # The animation API uses a builder pattern to animate a GameObject : 1 2 3 var tweenBuilder = transform . Tween (); tweenBuilder . Position ( new Vector3 ( 0 , 3 , 0 )) tweenBuilder . Run (); Or using the fluent style: 1 2 3 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (); Method calls can be chained together: 1 2 3 4 5 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Scale ( new Vector3 ( 2 , 2 , 2 )) . Rotation ( new Vector3 ( 0 , 180 , 0 )) . Run (); An action can be called in the builder's run method. For example, to set the GameObject to inactive (or some other operation): 1 2 3 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (() => gameObject . SetActive ( false )); Tweens can be executed in a sequence by passing a boolean to the Run method: 1 2 3 4 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Position ( new Vector3 ( 0 , 0 , 0 )) . Run ( true ); A third parameter combination exists for the Run method that allows for sequential tweens and a callback function when the animation completes: 1 2 3 4 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Position ( new Vector3 ( 0 , 0 , 0 )) . Run ( true , () => gameObject . SetActive ( false )); Also available are shortcuts to move, scale, and rotate a Transform if the builder pattern is not desirable: 1 2 3 4 transform . TweenPosition ( new Vector3 ( 0 , 3 , 0 )); transform . TweenScale ( new Vector3 ( 2 , 2 , 2 )); transform . TweenRotation ( new Vector3 ( 0 , 180 , 0 )); transform . TweenRotation ( Quaternion . Euler ( 0 , 180 , 0 )); Animating RectTransforms # In addition to the Transform tween options. For example, a UI component can be rotated like a regular Transform : 1 transform . TweenRotation ( new Vector3 ( 0 , 360 , 0 )); Note that resizing is a separate operation from scaling for a RectTransform : 1 rectTransform . TweenSize ( new Vector2 ( 500 , 500 )); Inside of a custom UI component, the Transform can be accessed as a RectTransform . 1 ( transform as RectTransform ). TweenSize ( new Vector2 ( 500 , 500 )); Animating Renderers # If a Renderer component has Material , the color and alpha can be animated: 1 2 3 4 renderer . Tween () . Color ( Color . red ) . Alpha ( 0.5f ) . Run (); Note that the Material must have a its Rendering Mode set to Transparent for the alpha transition have an effect. The builder pattern is optional for these operations: 1 2 renderer . TweenColor ( Color . red ); renderer . TweenAlpha ( 0.5f ); Customizing Animations # A custom animation duration and ease can be used in all of the animation API operations. Duration # The amount of time of the animation's transition can be customized by supplying the Tween builder method with a custom duration: 1 2 3 4 5 6 // All tween animations default to 2 seconds. transform . Tween ( 2.0f ) . Position ( new Vector3 ( 0 , 3 , 0 )) . Scale ( new Vector3 ( 2 , 2 , 2 )) . Rotation ( new Vector3 ( 2 , 2 , 2 ), 1f ) // Except this one that takes 1 second. . Run (); Easing # Be sure to import the ease namespace when specifying an Ease: 1 using FireChickenGames.DevKit.Tweening.Ease ; An ease has a EaseFunctionType and an EaseDirectionType . The default EaseFunctionType is Linear , but there are many ease functions to choose from. Ease Function Type Description Linear Transition at a constant speed. Quadratic Transition at a polynomial rate of x 2 . Cubic Transition at a polynomial rate of x 3 . Quartic Transition at a polynomial rate of x 3 . Quintic Transition at a polynomial rate of x 5 . Sine Transition at the rate of a sine wave's curve. Back Transition back beyond the start value before continuing to the target value. Bounce Transition as if the value is bouncing like a ball hitting the ground. Circular Transition symmetrically in and out at the rate of a quarter circle. Elastic Transition in a \"stretchy\" fashion. Exponential This transition is effectively a combination of the Quartic and Quintic functions. The default EaseDirectionType is In . Ease Direction Type Description In Apply the ease function at the start of the transition. Out Apply the ease function at the end of the transition. InOut Apply the ease function at the start and end of the transition. OutIn Apply the inverted ease function at the start and end of the transition. Creating an ease is simple: 1 var ease = new Ease ( EaseFunctionType . Quadratic , EaseDirectionType . Out ); The ease can be supplied either to the builder (making it the default ease for all of the builder's tweens): 1 2 3 transform . Tween ( ease ) . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (); Alternatively, the ease can be supplied to the individual tween method calls, making it apply only to a specific tween: 1 transform . TweenPosition ( new Vector3 ( 0 , 3 , 0 ), 0.5f , ease ); Transform Components # Component Description On Collision \u2192 Apply Transform Apply a Transform 's position, scale, and rotation to a colliding GameObject . On Collision \u2192 Set Parent Set the parent GameObject of the colliding GameObject . On Collision \u2192 Apply Transform # This component sets the colliding Transform to the specified Transform 's position, scale, and rotation. This is useful for \"teleporting\" a GameObject , e.g. when a player's character falls to its death. On Collision \u2192 Set Parent # This component simply sets the colliding GameObject 's parent. This is useful for implementing moving platforms that allow the player to move with the platform. Other Components # Component Description Character Used to animate a bare-bones character - useful for simple prototypes/demonstrations. Coroutine Proxy Useful for running coroutines outside of Unity components. On Collision \u2192 Destroy Destroy a GameObject when collided with. Subject Base An abstract component that adds a simple, reusable mechanism for selecting a GameObject for the child component. Character # This component allows a player to control an animated humanoid character model. The simple implementation of running and jumping is suitable for prototypes, demonstrations, testing, and simple platformer games. Coroutine Proxy # This component is used extensively by the DevKit animation API. It should only ever be attached to a GameObject programmatically and for the specific use-case where coroutines need to be run outside of a MonoBehavior . On Collision \u2192 Destroy # This component simply destroys a GameObject when a collision occurs. Subject Base # This is an abstract component that other components extend. It provides a way to reference a GameObject other than the one a derived component is attached to. This adds flexibility when creating components found in DevKit and custom components that depend on DevKit . Subject Options # A Subject renders as a dropdown in the inspector with a set of options that defines which GameObject is referenced. Subject Option Description Game Object An explicitly specified GameObject . Self The GameObject the component is attached to. Parent The parent GameObject of the GameObject the component is attached to. Note that this will be null for a GameObject at the root of the scene. Player The first available GameObject with the \"Player\" tag. Usage # Using the SubjectBase component is as easy as extending a custom component class with it: 1 2 3 using FireChickenGames.DevKit.Components ; public class SubjectExample : SubjectBase { } This produces a custom component with a single subject field: Though helpful, the base class is not necessary to use a Subject field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using FireChickenGames.DevKit.Core ; using UnityEngine ; public class SubjectExample : MonoBehaviour { public Subject subject = Subject . AsSelf (); void Start () { // If this initialization step is missed, the subject.GameObject will // be null either \"Self\" or \"Parent\" is selected in the inspector. subject . SetSelf ( gameObject ); } } Accessing the Subject in the GameObject via the subject.GameObject : 1 var gameObjectName = subject . GameObject . name ; It is also possible to get components in a variety of ways from the Subject , similar to how components are retrieved in MonoBehavior classes: 1 2 subject . GetComponent < Collider >(); subject . TryGetComponent < Collider >(); A third way, unique to DevKit , is available that gets OR adds a component if does not exist on the Subject : 1 2 3 4 5 6 7 8 9 10 11 12 using FireChickenGames.DevKit.Components ; using UnityEngine ; public class SubjectExample : SubjectBase { public Collider myCollider ; void Start () { myCollider = subject . GetOrAddComponent ( myCollider ); } } The Subject can be programmatically switched: 1 2 3 4 subject . SwitchToGameObject (); subject . SwitchToSelf (); subject . SwitchToParent (); subject . SwitchToPlayer ();","title":"DevKit"},{"location":"devkit/#animation-components","text":"Component Description Animate Base The core animation component which other animation components extend. Animate Animates a GameObject with one or more Animation Settings . Animation Settings Contains properties that define a set of animations used to configure other components. Follow This component moves a GameObject along the x , y , and/or z dimensions of another GameObject . Move Point To Point Moves a GameObject from one location to another location. On Collision \u2192 Animate Animates a GameObject when collided with. On Collision \u2192 Move To Moves a GameObject to the location of another GameObject . Recolor Randomly Randomly changes the color of a Material . Rotate Perpetually Continually rotates a GameObject .","title":"Animation Components"},{"location":"devkit/#animationbase","text":"This is an abstract component that other animation components inherit. It cannot be added directly to a GameObject . 1 2 3 using FireChickenGames.DevKit.Components ; public class AnimationExample : AnimationBase { } The component provides an extensible base implementation that other animation components use to accomplish specific animation effects.","title":"AnimationBase"},{"location":"devkit/#animate","text":"The component can provide a simple one-off animation. Or a series of animations.","title":"Animate"},{"location":"devkit/#animation-settings","text":"The component is used to visually configure an animation. Certain other components, such as the Animate component, use this component to define which animations they run.","title":"Animation Settings"},{"location":"devkit/#follow","text":"This component moves a GameObject along the x , y , and/or z dimensions of another GameObject . Animation Type Option Description Smooth Smooths the follow motion using Unity's Vector3.SmoothDamp function - useful for a follow camera. Ease Use a DevKit tween animation to animate the follow motion. One To One Lock the position of the following GameObject , with no smoothing or animation, to the GameObject it is following.","title":"Follow"},{"location":"devkit/#move-point-to-point","text":"The component moves the animated GameObject from one location to another location.","title":"Move Point To Point"},{"location":"devkit/#on-collision-animate","text":"The component is used to apply animation configuration from an AnimationSettings component to the animated GameObject . The AnimationSettings can either come from the colliding GameObject (if it has an AnimationSettings component)... ...or be explicitly set in the inspector.","title":"On Collision \u2192 Animate"},{"location":"devkit/#on-collision-move-to","text":"The component moves the component's GameObject toward the GameObject it collided with. Colliding objects are filterable by their tag.","title":"On Collision \u2192 Move To"},{"location":"devkit/#recolor-randomly","text":"The component changes the color of a material to another random color. This component is mainly for to demonstrate how to animate a color change.","title":"Recolor Randomly"},{"location":"devkit/#rotate-perpetually","text":"The component simply rotates a GameObject indefinitely.","title":"Rotate Perpetually"},{"location":"devkit/#animation-api","text":"The DevKit animation API allows for convenient animation of Transform , RectTransform , and Renderer components via C# extension methods. To get started, be sure to import the Tweening namespace: 1 using FireChickenGames.DevKit.Tweening ;","title":"Animation API"},{"location":"devkit/#animating-transforms","text":"The animation API uses a builder pattern to animate a GameObject : 1 2 3 var tweenBuilder = transform . Tween (); tweenBuilder . Position ( new Vector3 ( 0 , 3 , 0 )) tweenBuilder . Run (); Or using the fluent style: 1 2 3 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (); Method calls can be chained together: 1 2 3 4 5 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Scale ( new Vector3 ( 2 , 2 , 2 )) . Rotation ( new Vector3 ( 0 , 180 , 0 )) . Run (); An action can be called in the builder's run method. For example, to set the GameObject to inactive (or some other operation): 1 2 3 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (() => gameObject . SetActive ( false )); Tweens can be executed in a sequence by passing a boolean to the Run method: 1 2 3 4 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Position ( new Vector3 ( 0 , 0 , 0 )) . Run ( true ); A third parameter combination exists for the Run method that allows for sequential tweens and a callback function when the animation completes: 1 2 3 4 transform . Tween () . Position ( new Vector3 ( 0 , 3 , 0 )) . Position ( new Vector3 ( 0 , 0 , 0 )) . Run ( true , () => gameObject . SetActive ( false )); Also available are shortcuts to move, scale, and rotate a Transform if the builder pattern is not desirable: 1 2 3 4 transform . TweenPosition ( new Vector3 ( 0 , 3 , 0 )); transform . TweenScale ( new Vector3 ( 2 , 2 , 2 )); transform . TweenRotation ( new Vector3 ( 0 , 180 , 0 )); transform . TweenRotation ( Quaternion . Euler ( 0 , 180 , 0 ));","title":"Animating Transforms"},{"location":"devkit/#animating-recttransforms","text":"In addition to the Transform tween options. For example, a UI component can be rotated like a regular Transform : 1 transform . TweenRotation ( new Vector3 ( 0 , 360 , 0 )); Note that resizing is a separate operation from scaling for a RectTransform : 1 rectTransform . TweenSize ( new Vector2 ( 500 , 500 )); Inside of a custom UI component, the Transform can be accessed as a RectTransform . 1 ( transform as RectTransform ). TweenSize ( new Vector2 ( 500 , 500 ));","title":"Animating RectTransforms"},{"location":"devkit/#animating-renderers","text":"If a Renderer component has Material , the color and alpha can be animated: 1 2 3 4 renderer . Tween () . Color ( Color . red ) . Alpha ( 0.5f ) . Run (); Note that the Material must have a its Rendering Mode set to Transparent for the alpha transition have an effect. The builder pattern is optional for these operations: 1 2 renderer . TweenColor ( Color . red ); renderer . TweenAlpha ( 0.5f );","title":"Animating Renderers"},{"location":"devkit/#customizing-animations","text":"A custom animation duration and ease can be used in all of the animation API operations.","title":"Customizing Animations"},{"location":"devkit/#duration","text":"The amount of time of the animation's transition can be customized by supplying the Tween builder method with a custom duration: 1 2 3 4 5 6 // All tween animations default to 2 seconds. transform . Tween ( 2.0f ) . Position ( new Vector3 ( 0 , 3 , 0 )) . Scale ( new Vector3 ( 2 , 2 , 2 )) . Rotation ( new Vector3 ( 2 , 2 , 2 ), 1f ) // Except this one that takes 1 second. . Run ();","title":"Duration"},{"location":"devkit/#easing","text":"Be sure to import the ease namespace when specifying an Ease: 1 using FireChickenGames.DevKit.Tweening.Ease ; An ease has a EaseFunctionType and an EaseDirectionType . The default EaseFunctionType is Linear , but there are many ease functions to choose from. Ease Function Type Description Linear Transition at a constant speed. Quadratic Transition at a polynomial rate of x 2 . Cubic Transition at a polynomial rate of x 3 . Quartic Transition at a polynomial rate of x 3 . Quintic Transition at a polynomial rate of x 5 . Sine Transition at the rate of a sine wave's curve. Back Transition back beyond the start value before continuing to the target value. Bounce Transition as if the value is bouncing like a ball hitting the ground. Circular Transition symmetrically in and out at the rate of a quarter circle. Elastic Transition in a \"stretchy\" fashion. Exponential This transition is effectively a combination of the Quartic and Quintic functions. The default EaseDirectionType is In . Ease Direction Type Description In Apply the ease function at the start of the transition. Out Apply the ease function at the end of the transition. InOut Apply the ease function at the start and end of the transition. OutIn Apply the inverted ease function at the start and end of the transition. Creating an ease is simple: 1 var ease = new Ease ( EaseFunctionType . Quadratic , EaseDirectionType . Out ); The ease can be supplied either to the builder (making it the default ease for all of the builder's tweens): 1 2 3 transform . Tween ( ease ) . Position ( new Vector3 ( 0 , 3 , 0 )) . Run (); Alternatively, the ease can be supplied to the individual tween method calls, making it apply only to a specific tween: 1 transform . TweenPosition ( new Vector3 ( 0 , 3 , 0 ), 0.5f , ease );","title":"Easing"},{"location":"devkit/#transform-components","text":"Component Description On Collision \u2192 Apply Transform Apply a Transform 's position, scale, and rotation to a colliding GameObject . On Collision \u2192 Set Parent Set the parent GameObject of the colliding GameObject .","title":"Transform Components"},{"location":"devkit/#on-collision-apply-transform","text":"This component sets the colliding Transform to the specified Transform 's position, scale, and rotation. This is useful for \"teleporting\" a GameObject , e.g. when a player's character falls to its death.","title":"On Collision \u2192 Apply Transform"},{"location":"devkit/#on-collision-set-parent","text":"This component simply sets the colliding GameObject 's parent. This is useful for implementing moving platforms that allow the player to move with the platform.","title":"On Collision \u2192 Set Parent"},{"location":"devkit/#other-components","text":"Component Description Character Used to animate a bare-bones character - useful for simple prototypes/demonstrations. Coroutine Proxy Useful for running coroutines outside of Unity components. On Collision \u2192 Destroy Destroy a GameObject when collided with. Subject Base An abstract component that adds a simple, reusable mechanism for selecting a GameObject for the child component.","title":"Other Components"},{"location":"devkit/#character","text":"This component allows a player to control an animated humanoid character model. The simple implementation of running and jumping is suitable for prototypes, demonstrations, testing, and simple platformer games.","title":"Character"},{"location":"devkit/#coroutine-proxy","text":"This component is used extensively by the DevKit animation API. It should only ever be attached to a GameObject programmatically and for the specific use-case where coroutines need to be run outside of a MonoBehavior .","title":"Coroutine Proxy"},{"location":"devkit/#on-collision-destroy","text":"This component simply destroys a GameObject when a collision occurs.","title":"On Collision \u2192 Destroy"},{"location":"devkit/#subject-base","text":"This is an abstract component that other components extend. It provides a way to reference a GameObject other than the one a derived component is attached to. This adds flexibility when creating components found in DevKit and custom components that depend on DevKit .","title":"Subject Base"},{"location":"devkit/#subject-options","text":"A Subject renders as a dropdown in the inspector with a set of options that defines which GameObject is referenced. Subject Option Description Game Object An explicitly specified GameObject . Self The GameObject the component is attached to. Parent The parent GameObject of the GameObject the component is attached to. Note that this will be null for a GameObject at the root of the scene. Player The first available GameObject with the \"Player\" tag.","title":"Subject Options"},{"location":"devkit/#usage","text":"Using the SubjectBase component is as easy as extending a custom component class with it: 1 2 3 using FireChickenGames.DevKit.Components ; public class SubjectExample : SubjectBase { } This produces a custom component with a single subject field: Though helpful, the base class is not necessary to use a Subject field: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 using FireChickenGames.DevKit.Core ; using UnityEngine ; public class SubjectExample : MonoBehaviour { public Subject subject = Subject . AsSelf (); void Start () { // If this initialization step is missed, the subject.GameObject will // be null either \"Self\" or \"Parent\" is selected in the inspector. subject . SetSelf ( gameObject ); } } Accessing the Subject in the GameObject via the subject.GameObject : 1 var gameObjectName = subject . GameObject . name ; It is also possible to get components in a variety of ways from the Subject , similar to how components are retrieved in MonoBehavior classes: 1 2 subject . GetComponent < Collider >(); subject . TryGetComponent < Collider >(); A third way, unique to DevKit , is available that gets OR adds a component if does not exist on the Subject : 1 2 3 4 5 6 7 8 9 10 11 12 using FireChickenGames.DevKit.Components ; using UnityEngine ; public class SubjectExample : SubjectBase { public Collider myCollider ; void Start () { myCollider = subject . GetOrAddComponent ( myCollider ); } } The Subject can be programmatically switched: 1 2 3 4 subject . SwitchToGameObject (); subject . SwitchToSelf (); subject . SwitchToParent (); subject . SwitchToPlayer ();","title":"Usage"},{"location":"rpg/","text":"The RPG for Game Creator is in development. It will contain a collection of modules: Items Magic Maps Skills Dependencies # RPG for Game Creator is an extension. It requires Game Creator and will not work without it. They can be purchased from the Unity Asset Store: Game Creator The individual modules will have separate dependencies... Items \u2b95 Inventory Magic \u2b95 No dependency. Maps \u2b95 Quests Skills \u2b95 Stats What\u2019s Included # Full source code. Examples modules that contain scenes that demonstrate the assets features.","title":"Getting Started"},{"location":"rpg/#dependencies","text":"RPG for Game Creator is an extension. It requires Game Creator and will not work without it. They can be purchased from the Unity Asset Store: Game Creator The individual modules will have separate dependencies... Items \u2b95 Inventory Magic \u2b95 No dependency. Maps \u2b95 Quests Skills \u2b95 Stats","title":"Dependencies"},{"location":"rpg/#whats-included","text":"Full source code. Examples modules that contain scenes that demonstrate the assets features.","title":"What\u2019s Included"},{"location":"rpg/roadmap/","text":"Projected Features # Items Module Custom Inventory UI. Recipe-based Crafting. Pickups (collision-based and with confirmation UI). Map Module Navigable World Map UI. HUD Point-of-Interest (POI) Map UI. Teleport to Locales. Quest Module Integration (Quest locations in World and POI map). 3rd Party Mini-Map Integration. Magic Module Spell Collection UI. Ray, AOE, and Projectile Attack Spells. AOE and Self-buff Spells. Swappable Visual Effects. Skills Module Skill Tree UI. Lightweight Graph-based Skills Trees. 3rd Party Skill-Tree Integration.","title":"Roadmap"},{"location":"rpg/roadmap/#projected-features","text":"Items Module Custom Inventory UI. Recipe-based Crafting. Pickups (collision-based and with confirmation UI). Map Module Navigable World Map UI. HUD Point-of-Interest (POI) Map UI. Teleport to Locales. Quest Module Integration (Quest locations in World and POI map). 3rd Party Mini-Map Integration. Magic Module Spell Collection UI. Ray, AOE, and Projectile Attack Spells. AOE and Self-buff Spells. Swappable Visual Effects. Skills Module Skill Tree UI. Lightweight Graph-based Skills Trees. 3rd Party Skill-Tree Integration.","title":"Projected Features"}]}